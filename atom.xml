<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lee想主义</title>
  
  <subtitle>一腔热血的lee想主义</subtitle>
  <link href="https://www.leeee.xyz/atom.xml" rel="self"/>
  
  <link href="https://www.leeee.xyz/"/>
  <updated>2025-04-15T07:23:40.199Z</updated>
  <id>https://www.leeee.xyz/</id>
  
  <author>
    <name>lee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>别跟随自己的感受</title>
    <link href="https://www.leeee.xyz/posts/FeelingsVsFacts/"/>
    <id>https://www.leeee.xyz/posts/FeelingsVsFacts/</id>
    <published>2024-11-22T08:17:32.000Z</published>
    <updated>2025-04-15T07:23:40.199Z</updated>
    
    <content type="html"><![CDATA[<h1 id="感觉是最不“靠谱”的东西"><a href="#感觉是最不“靠谱”的东西" class="headerlink" title="感觉是最不“靠谱”的东西"></a>感觉是最不“靠谱”的东西</h1><p>“Follow your feeling” 这句话经常出现在人们面对选择时的回答中。<br>确实，无论做什么事情，按照人的惯性思维，当不知道该如何选择时，最优解往往是“跟着感觉走”，毕竟感觉是自己内心的真实反映。</p><p>然而，这种说法背后隐藏了一个重要前提：<strong>当一件事情的所有决定权都掌握在你手里时，跟着感觉走才是最优解</strong>。<br>例如，今天晚上吃什么，这完全是你的个人决定，任何人都无法否决你的选择。在这种情况下，遵从自己的感觉自然是最佳方案。</p><p>但如果一件事情牵涉到多个因素，且不仅仅是你一个人能够决定或影响其走向时，通过“感觉”来判断和选择往往是最不可靠的方式。</p><hr><h2 id="客观因素比感觉更重要"><a href="#客观因素比感觉更重要" class="headerlink" title="客观因素比感觉更重要"></a><strong>客观因素比感觉更重要</strong></h2><p>观察那些厉害的人（指能够游刃有余处理复杂问题的人），会发现他们在做决定时，依赖的往往是<strong>客观存在的现实因素</strong>。</p><p>例如，一个成功的商人在选择产品时，大部分都会基于以下数据：</p><ul><li><strong>真实的市场销售数据</strong></li><li><strong>消费者的消费意愿</strong></li><li><strong>竞争环境分析</strong></li></ul><p>这些可量化的客观数据是他们选择方向的依据。反观缺乏经验的商人，通常会用“我觉得市场需要这个产品”这样的主观感受来判断。<br>然而，这种依赖感觉的决策方式成功率显然低很多。</p><p>决定产品畅销与否的因素有很多，例如：市场经济、消费者需求、运营推广等。而主观的感觉往往是<strong>最不重要的</strong>。<br>因此，当他们遇到现象级的爆款时，常常会觉得莫名其妙：“这种东西怎么就能火起来呢？”</p><hr><h2 id="情绪影响感觉，感觉影响判断"><a href="#情绪影响感觉，感觉影响判断" class="headerlink" title="情绪影响感觉，感觉影响判断"></a><strong>情绪影响感觉，感觉影响判断</strong></h2><p>情绪会严重干扰你的感觉。如果你对某个人或某件事怀有偏见或敌意，那么通过“感觉”做出的判断准确率会大打折扣。</p><p>在处理<strong>以目标为导向的事情</strong>时，不妨尝试以下调整：</p><ul><li><strong>将“我觉得这件事应该怎么做”替换为“这件事得这么做”</strong>。</li><li>对于“为什么得这么做”，找到<strong>论据</strong>支撑你的想法，而不是简单地说“我感觉这样做比较好”。</li></ul><hr><h2 id="排除感觉的干扰，提升成功概率"><a href="#排除感觉的干扰，提升成功概率" class="headerlink" title="排除感觉的干扰，提升成功概率"></a><strong>排除感觉的干扰，提升成功概率</strong></h2><p>所以说，<strong>感觉是最不“靠谱”的东西</strong>。<br>当你学会剔除感觉的“幻觉”，用更客观、更理性的方法去思考问题时，你会更容易看透事情的本质，进而提高事情的成功概率。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul><li>感觉适用于完全由自己掌控的决策，但在复杂、多方协作的情境下，感觉并不可靠。</li><li>客观数据和理性分析是高效决策的核心。</li><li>学会克服情绪对感觉的干扰，以论据为支撑做出更优选择。</li></ul>]]></content>
    
    
    <summary type="html">“Follow your feeling” 这句话经常出现在人们面对选择时的回答中。确实，无论做什么事情，按照人的惯性思维，当不知道该如何选择时，最优解往往是“跟着感觉走”，毕竟感觉是自己内心的真实反映。</summary>
    
    
    
    <category term="日常记录" scheme="https://www.leeee.xyz/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="生活感悟" scheme="https://www.leeee.xyz/tags/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>2024年7月23日随笔</title>
    <link href="https://www.leeee.xyz/posts/2024%E5%B9%B47%E6%9C%8823%E6%97%A5%E9%9A%8F%E7%AC%94/"/>
    <id>https://www.leeee.xyz/posts/2024%E5%B9%B47%E6%9C%8823%E6%97%A5%E9%9A%8F%E7%AC%94/</id>
    <published>2024-07-23T14:56:14.000Z</published>
    <updated>2025-04-15T07:23:40.193Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 题外话 ： <strong>“延迟退休”</strong>最近这个话题可谓是议论众多。很多人自嘲35岁不到都已经面临失业即退休的窘境了，还谈什么延迟退休。</p></blockquote><h1 id="工作上"><a href="#工作上" class="headerlink" title="工作上"></a><strong>工作上</strong></h1><p>产品需求一如既往地来回变动，依旧是写不完的业务代码😓。不过唯一有趣的是我优化了一下线上环境的某个接口，核心查询优化了，速度提升了一半。在对于在繁杂的业务需求里面唯一能够找到成就感的东西了。</p><h1 id="生活上"><a href="#生活上" class="headerlink" title="生活上"></a><strong>生活上</strong></h1><p>今天是老爸生日🎉老姐依旧是带着一家老小回家庆祝。</p><p>爸爸没有过生日的习惯却很期待生日。因为家里都很很热闹，而我在外地也只能是通个电话云祝福一下。搞笑的是我跟我爸都是那种表达爱意都很含蓄的那种，连一句生日快乐都会觉得很害羞哈哈，都很默契地试探性祝福。</p><p>今天跟老婆🏊‍游泳了1公里。老婆从一个旱鸭子到现在能够自如游1km，游泳也算是她最喜欢的运动爱好了，继续坚持加油吧！</p><h1 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a><strong>感悟</strong></h1><p>工作的事情一成不变会让生活感到无聊。生活上要敢于打破常规，不是理应怎么样，而且我想要怎么样。</p><p>最起码要敢于去想，再去考虑要如何去实现，最后成不成再说吧！☀</p><p><strong>重复地过每一天,还是过不重复的每一天，这不一样</strong>。如果都是重复的每一天，那该多无趣阿！</p>]]></content>
    
    
    <summary type="html">重复地过每一天,还是过不重复的每一天，这不一样。</summary>
    
    
    
    <category term="日记" scheme="https://www.leeee.xyz/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="日记" scheme="https://www.leeee.xyz/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>2023年回首总结</title>
    <link href="https://www.leeee.xyz/posts/84s8da11/"/>
    <id>https://www.leeee.xyz/posts/84s8da11/</id>
    <published>2024-01-15T14:12:14.000Z</published>
    <updated>2025-04-15T07:23:40.192Z</updated>
    
    <content type="html"><![CDATA[<p>2023年转眼就过去了，这一年经历了许多不一样的事情，无论是生活还是工作或者情感上。不管好的坏的，我相信都是命运里最好的安排。也希望在新的一年里，能够积极面对一切事情，不断进步，保持对生活的热爱！</p><p>作为一个理工生，我觉得我的内心世界还是比较丰富的，奈何文笔不够。每次脑袋里想要表达的东西真的很多，但是一旦要发表出来，就词不达意或者词穷。可能就是写的东西还不够多。用进废退，以后就多写一些日常记录跟总结来锻炼自己的语言表达能力，只要有写，就会进步！</p><p><strong>旅游</strong>：</p><p>今年我和老婆（当时还是女朋友哈哈哈）去了重庆、大理、丽江、昆明、柳州、阳朔、惠州、珠海。每去到一个地方，不同的人文气息都会给我带来不同的感受。尝试过重庆美食的热辣，也见识到桂林山水甲天下的宏观。从大理到丽江，我见到了小时候课本描述过的远方。我喜欢在旅途在路上的感觉，见不一样的风景，这种感受是能够让你记一辈子的。</p><p><strong>工作</strong>：</p><p>这一年的工作可谓是温水煮青蛙。工作的强度比较低，工作之余又没有太多热情去钻研一些新的技术。生于忧患而死于安乐用来形容最恰当了。人一旦在舒适圈呆久了，就会懒得突破这个圈层了。今年的互联网市场也是寒冬，我们项目组在今年最后一个月被解散了。在离职这段日子，我也有了更多思考的时间。吃技术这一碗饭是需要长期不断地去进步，时代在进步，大数据模型、chatgpt等工具的出现，颠覆了传统的互联网技术。互联网的红利已过去，时间会像是一把筛子，过滤掉红利期滥竽充数的人。所以保持进步，保持好奇心，不断完善自己的技能，在接下来的日子，才能有一定的立足之地。</p><p><strong>生活</strong></p><p>今年我娶到了我青春里最爱的那个她啦~我从男朋友变成了老公了，从接她放学到接她下班最后变成等她回家！很幸运能够遇到一个灵魂彼此接近、让我想要保护一生的人。身份的转换，肩上的责任都是承担起一个家庭啦。回想起刚毕业实习的时候，拿着微薄的实习薪酬，我们照样憧憬着美好的未来。加油吧！少年，永远要相信美好的事情即将发生。</p><p><strong>总结</strong></p><p>上面劈里啪啦说了一堆，可能逻辑不同、语法甚至都有问题，但是我相信只要有记录就一定会进步的！新的一年里，要改掉我这一年的不足，保持好奇心、提升执行力。多表达、多行动！内心的世界很丰富，需要让世界看到！最后分享一下最近觉得不错的一句话：”想的时候什么都是问题，做的时候什么都是答案“</p>]]></content>
    
    
    <summary type="html">人生是一场马拉松，一时的得失并不能代表什么。坚持长期主义，你想要的终将会得到。</summary>
    
    
    
    <category term="日常记录" scheme="https://www.leeee.xyz/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="总结思考" scheme="https://www.leeee.xyz/tags/%E6%80%BB%E7%BB%93%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>ffmpeg视频压缩方案</title>
    <link href="https://www.leeee.xyz/posts/84d8da12/"/>
    <id>https://www.leeee.xyz/posts/84d8da12/</id>
    <published>2022-12-08T06:02:34.000Z</published>
    <updated>2025-04-15T07:23:40.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="视频压缩解决方案"><a href="#视频压缩解决方案" class="headerlink" title="视频压缩解决方案"></a>视频压缩解决方案</h1><blockquote><p>什么是ffmepg？按维基百科的说法:FFmpeg 是一个开放源代码的自由软件，可以执行音频和视频多种格式的录影、转换、串流功能，包含了libavcodec——这是一个用于多个项目中音频和视频的解码器库，以及libavformat——一个音频与视频格式转换库</p></blockquote><p>视频压缩,说白了就是要让视频的大小降低,同时尽量不降低质量。如果为了降低大小,画质惨不忍睹这也是不能接受的。接下来就让我们了解一下与视频画质以及大小相关的一些要素</p><h2 id="1-视频相关名称解释"><a href="#1-视频相关名称解释" class="headerlink" title="1.视频相关名称解释"></a>1.视频相关名称解释</h2><p><strong>帧率</strong>：FPS（frame per second 每秒钟要多少帧画面） GOP（表示多少秒一个I帧）</p><p><strong>码率</strong>：编码器每秒编出的数据大小，单位是kbps，比如800kbps代表编码器每秒产生800kb（或100KB）的数据。</p><p><strong>分辨率</strong>：单位英寸中所包含的像素点数；</p><p><strong>VGA</strong>：Video Graphics Array（视频图像分辨率）</p><h2 id="2-如何让视频变小"><a href="#2-如何让视频变小" class="headerlink" title="2.如何让视频变小"></a>2.如何让视频变小</h2><p>想要让视频变小,其中的关键因素是码率以及分辨率。帧率的话大部分情况下较小影响。如果非特殊的一些业务需求，帧率一般不变即可。<br><img src="/posts/84d8da12/1.png"><br>这里有一条公式:<strong>码率&#x3D;文件实际大小(kb) X 8&#x2F;时长(s)</strong>,由此我们可以看出来,码率越大视频所占空间大小就越多。</p><p>按照这样子的说法,我们肯定会想那我把码率调到最低岂不是美滋滋。确实视频的空间大小会急速下降,但是你打开视频肯定会惊呆,画质十分感人根本就看不清。你想一下,码率其实就是编码器每秒编出的数据大小，如果你的码率很低,编码器每秒传输的数据很少,编码器就会用一些奇奇怪怪的马赛克来补充你视频的画面,这就是解释了为什么视频看起来会很模糊还会有一层朦胧的感觉。</p><p>在码率一定的情况下，<strong>分辨率与清晰度成反比关系</strong>：分辨率越高，图像越不清晰，分辨率越低，图像越清晰。 在分辨率一定的情况下，<strong>码率与清晰度成正比关系</strong>，码率越高，图像越清晰；码率越低，图像越不清晰</p><p>还有一个需要注意的地方:<strong>码率跟分辨率需要平衡</strong>。假设分辨率很高,码率比较低,这样子的画质也会有一定的影响的。720p较高的码率跟1080p较低的码率,720p的视频画质可能会看起来更加清晰。</p><h2 id="3-实战"><a href="#3-实战" class="headerlink" title="3.实战"></a>3.实战</h2><p>了解影响视频空间大小的因素后，我们就可以开始对视频的参数进行调整压缩了。为了快速开发,我采用了php的laravel框架以及<a href="https://github.com/PHP-FFMpeg/PHP-FFMpeg">PHP-FFMpeg</a> 组件进行开发（因为其中涉及到一些云服务商以及业务的处理）。需要依赖ffmpeg，这里就不对ffmpeg安装进行过多讲解，google搜索很多方法。以下是主要的核心压缩代码，已屏蔽了业务相关的代码</p><pre><code class="php">//创建ffmpeg驱动$driver =  FFMpeg::create([&#39;ffmpeg.binaries&#39;  =&gt; &#39;ffmpeg_binaries&#39;,&#39;ffprobe.binaries&#39; =&gt; &#39;ffprobe_binaries&#39;,&#39;timeout&#39;          =&gt; &#39;&#39;, // The timeout for the underlying process&#39;ffmpeg.threads&#39;   =&gt; &#39;&#39;,   // The number of threads that FFMpeg should use,]);//打开视频$video = $driver-&gt;open($filePath)//这里是拿ffprobe的驱动获取视频的信息$streams = $driver-&gt;getFFProbe()            -&gt;streams($filePath)            -&gt;videos()            -&gt;first();//拿到对应的分辨率$width = $streams-&gt;get(&#39;width&#39;);$height = $streams-&gt;get(&#39;height&#39;);//压缩到最低分辨率,这里取最短边$minResolution = 720;//这里是设置的动态码率（最大为1200k）、分辨率设置为720p,如果最短边低于720则不处理$addParams = [&quot;-maxrate&quot;, [&quot;1200k&quot;], &quot;-bufsize&quot;, &quot;5000k&quot;]; if ($width &gt; $height) &#123;       //最短边为高       if ($height &gt; $minResolution) &#123;          $addParams = array_merge($addParams, [&quot;-vf&quot;, sprintf(&quot;scale=-2:%d&quot;, $minResolution)]);        &#125;&#125; else &#123;//最短边为宽        if ($width &gt; $minResolution) &#123;            $addParams = array_merge($addParams, [&quot;-vf&quot;, sprintf(&quot;scale=%d:-2&quot;, $minResolution)]);         &#125;&#125;//这里设置了264编码$format = new X264();//因为默认设置了码率是1000k所以这里设置为null$format-&gt;setKiloBitrate(null);//这里了一些额外的参数进行压缩$format-&gt;setAdditionalParameters($addParams);    $video-&gt;save($format, $tempFile);</code></pre><p>以上的php代码其实就是在做一件事,组装ffmpeg命令最终输出文件,至于参数怎么设置可以根据你业务的需要进行调整。<strong>这里在vf参数的scale为啥要输入-2呢,输入-1或者-2都是动态进行调整，这样就不会导致你的视频因为调整视频分辨率而变形。输入-1有可能刚好计算出来的长度或者宽度不能够被2整除就会报错。</strong></p><pre><code class="shell">ffmpeg -y -i 输入视频文件路径 -threads 5 -vcodec libx264 -acodec aac -b:a 128k -maxrate 1200k -bufsize 5000k -vf scale=720:-2 输出视频文件路径</code></pre><blockquote><p>以上就是本次我对于视频压缩的一些做法以及见解,如何做好最优解是需要不断的发现问题并解决问题的。现在的压缩效果大体上能满足业务的需求,毕竟代码说到底就是在为业务服务。只要能满足业务需求，并且后期有足够的扩展空间就算是好的解决方案。</p></blockquote>]]></content>
    
    
    <summary type="html">视频压缩功能是业务中比较常见的一种需求功能。本文记录作者基于php以及ffmpeg开发的视频压缩服务中的一些做法以及思考点。希望能够帮助到需要的朋友,同时方便自己总结以及回顾。</summary>
    
    
    
    <category term="实战记录" scheme="https://www.leeee.xyz/categories/%E5%AE%9E%E6%88%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="ffmpeg" scheme="https://www.leeee.xyz/tags/ffmpeg/"/>
    
    <category term="音频处理" scheme="https://www.leeee.xyz/tags/%E9%9F%B3%E9%A2%91%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>ImageMagick安装</title>
    <link href="https://www.leeee.xyz/posts/49632e58/"/>
    <id>https://www.leeee.xyz/posts/49632e58/</id>
    <published>2022-06-24T03:24:57.000Z</published>
    <updated>2025-04-15T07:23:40.193Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>由于ImageMagick7以下不支持heic等图片格式，所以重新安装了ImageMagick7.1版本支持heic格式，并写此文章记录一下。<br>如果安装过程中遇到一些未知的错误，<strong><a href="https://imagemagick.org/script/download.php">https://imagemagick.org/script/download.php</a></strong> 可以去官网看文档解决，或者评论一起解决。</p></blockquote><p>#在Linux（centos7）上安装ImageMagick7.1库以及php的Imagick扩展</p><p>##1.在Linux上安装ImageMagick7.1<br>安装之前需要配置一下pkg-config,以便 ImageMagick 可以在您的系统上找到某些可选的委托库</p><pre><code class="php">PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/lib64/pkgconfig:/usr/local/lib/pkgconfigexport PKG_CONFIG_PATHLD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/lib:/usr/lib64:/usr/local/lib:/usr/local/lib64export LD_LIBRARY_PATH</code></pre><p>安装依赖库（这里我只安装<strong>heic（heif）</strong> 的依赖，其他格式类似一样安装）<br>安装x265(libheif依赖)</p><pre><code class="php">yum install -y fftw fftw-devel fftw-devel bzip2 bzip2-devel freetype-devel libjpeg-devel libpng-devel libtiff-devel giflib-devel zlib-devel ghostscript-devel djvulibre-devel libwmf-devel jasper-devel  libX11-devel libXext-devel libXt-devel lcms-devel libxml2-devel librsvg2-devel OpenEXR-devel openjpeg openjpeg-devel  openjpeg2 openjpeg2-devel openjpeg2-libs  gcc gcc-c++  make cmake automake  libtool   libtool-ltdl-devel lcms2  lcms2-devel LibRaw LibRaw-develwget https://www.nasm.us/pub/nasm/releasebuilds/2.13.03/nasm-2.13.03.tar.gztar -zxvf nasm-2.13.03.tar.gz  cd nasm-2.13.03 ./autogen.sh &amp;&amp; ./configure &amp;&amp; make &amp;&amp; make install</code></pre><p>安装<strong>libheif</strong>依赖</p><pre><code class="php">wget https://github.com/strukturag/libheif/releases/download/v1.12.0/libheif-1.12.0.tar.gztar -zxvf libheif-1.12.0.tar.gzcd libheif-1.12.0./autogen.sh &amp;&amp; ./configure &amp;&amp; make &amp;&amp; make install</code></pre><p>最后安装ImageMagick</p><pre><code class="php">wget https://imagemagick.org/archive/ImageMagick-7.1.0-39.tar.gztar -zxvf ImageMagick-7.1.0-39.tar.gzcd ImageMagick-7.1.0-39./configure &amp;&amp; make &amp;&amp; make install</code></pre><p>设置环境变量</p><pre><code class="php">echo &quot;export PATH=$PATH:/usr/local/ImageMagick/bin&quot; &gt;&gt; /etc/profile//如果需要移除旧版本yum remove ImageMagick -y//加载环境变量source /etc/profile//验证版本安装是否成功convert -version//查看支持格式列表convert -list format</code></pre><p>在编译的过程中如果出现报错</p><pre><code class="php">error: &#39;libraw_output_params_t&#39; has no member named &#39;no_interpolation&#39;</code></pre><p>则需要升级一下你的 libraw 版本</p><pre><code class="php">//先卸载当前librawyum remove libraw//安装更高版本的libraw （rpm安装命令）rpm -ivh https://mirrors.tuna.tsinghua.edu.cn/centos/7/os/x86_64/Packages/LibRaw-0.19.4-1.el7.x86_64.rpm（yum安装命令）yum localinstall -y https://mirrors.tuna.tsinghua.edu.cn/centos/7/os/x86_64/Packages/LibRaw-0.19.4-1.el7.x86_64.rpm</code></pre><p>安装完重新编辑即可<br>##2.安装PHP的Imagick扩展</p><pre><code class="php">//下载、解压、安装imagick-3.4.4wget https://pecl.php.net/get/imagick-3.4.4.tgztar -zxvf imagick-3.4.4.tgzcd imagick-3.4.4.tgz//usr/local/php/bin/phpize//ImageMagick 6.8以上版本目录为/usr/local/include/ImageMagick-X,在configure之前先做下软连接ln -s /usr/local/imagemagick/include/ImageMagick-7 /usr/local/imagemagick/include/ImageMagick./configure --with-php-config=/usr/local/php/bin/php-config --with-imagick=/usr/local/imagemagickmake &amp;&amp; make install</code></pre><p>最后在php.ini中加入imagick.so扩展即可</p><pre><code class="php">extensions=imagick.so</code></pre><p>通过升级ImageMagick7支持heic格式处理，由于我们服务器是aws的，在安装的过程中可谓一波三折。不过好在最终也是成功安装完成。希望记录下来过程，给有需要的朋友们一点帮助。</p><p>博客地址:<strong><a href="https://www.goldenleek.top/">https://www.goldenleek.top</a></strong> </p><p>欢迎骚扰~</p><h3 id="互勉：保持空杯心态-做一个有态度的程序员。"><a href="#互勉：保持空杯心态-做一个有态度的程序员。" class="headerlink" title="互勉：保持空杯心态,做一个有态度的程序员。"></a><strong>互勉：保持空杯心态,做一个有态度的程序员。</strong></h3>]]></content>
    
    
    <summary type="html">由于ImageMagick7以下不支持heic等图片格式，所以重新安装了ImageMagick7.1版本支持heic格式，并写此文章记录一下。</summary>
    
    
    
    <category term="实战记录" scheme="https://www.leeee.xyz/categories/%E5%AE%9E%E6%88%98%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>唯一邀请码生成策略</title>
    <link href="https://www.leeee.xyz/posts/75599f8a/"/>
    <id>https://www.leeee.xyz/posts/75599f8a/</id>
    <published>2022-06-17T06:27:18.000Z</published>
    <updated>2025-04-15T07:23:40.200Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>需求：按照随机策略生成一个不重复的邀请码（字母+数字），既要不重复又要保证性能。每个用户对应一个邀请码，必须做到唯一性。邀请码的需要手动输入所以长度不能太长，同时不能让用户猜到邀请码的生成逻辑，所以邀请的生成逻辑也必须要随机。</p></blockquote><h1 id="目的-：生成不重复的邀请码"><a href="#目的-：生成不重复的邀请码" class="headerlink" title="目的 ：生成不重复的邀请码"></a>目的 ：生成不重复的邀请码</h1><h2 id="1-如何做到不重复"><a href="#1-如何做到不重复" class="headerlink" title="1.如何做到不重复"></a>1.如何做到不重复</h2><ul><li><h3 id="方案一："><a href="#方案一：" class="headerlink" title="方案一："></a>方案一：</h3></li></ul><p>利用生成邀请码时间戳进行生成,并且加上随机数，能保证不同时间生成的邀请码大部分不同（不排序小概率碰撞）。为了减少碰撞率，可以精确到毫秒颗粒度，但同时也增长了邀请码的长度。</p><p>弊端：秒&#x2F;毫秒颗粒度的时间长度（10&#x2F;13位）+ 随机码（4位）会导致邀请码的长度达到10+位，这对于用户的体验是极其不好的，而且也容易被猜到邀请码的生成逻辑，因此此方案不推荐。</p><ul><li><h3 id="方案二："><a href="#方案二：" class="headerlink" title="方案二："></a>方案二：</h3></li></ul><p>1.通过方案一的弊端，我们知道生成一个合格的邀请码我们需要解决的第一个问题就是长度。长度的设置是关乎可生成邀请码的数量的范围，设置太少的话邀请码的范围有限，设置太长的码邀请码对于用户的体验不好。所以考虑这两个情况，我们可以将邀请码的长度定义6位。</p><hr><p>2.要解决的第二个问题就是重复的问题。要保证不重复，简单来说最好的方式就是自增，例如1，2，3，….这样子就能保证绝对唯一，可以将用户的自增id作为邀请码的自增值做绑定。这样做的好处就是能够保证不重复，但是很容易被用户猜测到生成逻辑以及一些用户的敏感数据。既然自增能够保证唯一性，那我们不妨换一种思维去思考，可不可以在自增的基础上面将规律给打乱，这样就能保证邀请码唯一且无规律了。</p><hr><p>做法：一个自增点会导致数量连续有规律，那么我们可以设置多个池子，每个池子维护一个自增点，随机去一个池子通过自增id生成，就能够做到随机了。因为邀请码的长度有限制，所以我们需要算出来邀请码最大的范围值有多少，然后将最大的范围值分成若干个池子。</p><p>6位(数字+字母)长度的邀请码,根据可取字符的数量，我们将邀请码的形式设置为36进制数，这样邀请码的范围值就是为000000~<br>zzzzzz,也就是等于十进制的2176782335，相当于我们最多能够生成2176782335个邀请码。如果此数量不满足业务上的需求，可以根据业务要求适当增删。我们假设每个池子能够存储邀请码的数量为10000个，则会有217678个池子。我们每个自增点就等于：<strong>邀请码 &#x3D; （池子number * 10000 + 自增点)转成32进制</strong> 的字符串。</p><p>用个图来表示以上的过程：</p><p><img src="/posts/75599f8a/1.png"></p><p>要注意红色字体,每个池子有最大自增点限制，为该池子能够存储邀请的最大数量。通过上述过程就能做到生成一个唯一且无明显规律的邀请码。当然要想最大程度无规律的话，可以将前几个池子给剔除掉，这样子就不会出现000001这样子的邀请码</p><hr><p>代码实践（PHP版本）:主要思路是利用redis集合的特点进行存储自增点以及池子。</p><pre><code class="php">&lt;?phpclass Code&#123;protected  Redis $redis;private $codeIncrementSet = &#39;code_increment_set&#39;;private $codeAvailableSet = &#39;code_available_set&#39;;public function __construct()&#123;    $this-&gt;redis = new Redis();    $this-&gt;init();&#125;//初始化private function init()&#123;   if (0 === $this-&gt;redis-&gt;exists($this-&gt;codeIncrementSet))&#123;    //添加1-217678序号的池子，并且自增点设置为0    $this-&gt;redis-&gt;zAdd($this-&gt;codeIncrementSet,array_fill(1,217678),0);    //保存1-217678序号的可用池子    $this-&gt;redis-&gt;sAddArray($this-&gt;codeAvailableSet,range(1,217678))   &#125;&#125;public function getCode()&#123;    //随机取一个可用的邀请码池子    if (is_null($index = $this-&gt;redis-&gt;srandmember($codeAvailableSet)))&#123;          throw new BusinessException(&#39;可用邀请码码数为空&#39;);    &#125;    //获取对应需要池子的自增点    $increment =  (int)$this-&gt;redis-&gt;zScore($this-&gt;codeIncrementSet,$index)        //计算code值    $number = (int)index * 10000 + $increment;        //维护自增点    $this-&gt;redis-&gt;zIncrBy($this-&gt;codeIncrementSet,1,$index);        //该池子被用完了    if (9999 === $increment)&#123;         $this-&gt;redis-&gt;sRem($this-&gt;codeAvailableSet,$index);    &#125;    //返回36进制的邀请码，用0部位     return str_pad(base_convert($number, 10, 36), 6, &#39;0&#39;, STR_PAD_LEFT);&#125;&#125;</code></pre><p>以上就是整体代码的实现，具体的一些细节可根据业务自定义调整。</p><blockquote><h2 id="2-如何做到高性能"><a href="#2-如何做到高性能" class="headerlink" title="2.如何做到高性能"></a>2.如何做到高性能</h2><p>生成用户邀请码是一个频繁的操作，如果每次实时生成的话性能会比较低。可用利用空间换时间的思维。预先生成一批邀请码然后在需要的时候直接拿出来用即可。这种思路在开发中很常见，异步处理，用空间换取时间。通过这种方式就能快速的生成邀请码。</p></blockquote><hr><p>以上就是如何生成唯一无规律邀请码的策略，方法很简单却很有效。将思路输出成文章的形式，能够更好地加深理解，以及能够让更多的人看到，指出其中的不足。</p><h3 id="互勉：保持空杯心态-做一个有态度的程序员。"><a href="#互勉：保持空杯心态-做一个有态度的程序员。" class="headerlink" title="互勉：保持空杯心态,做一个有态度的程序员。"></a><strong>互勉：保持空杯心态,做一个有态度的程序员。</strong></h3>]]></content>
    
    
    <summary type="html">需求：按照随机策略生成一个不重复的邀请码（字母+数字），既要不重复又要保证性能。每个用户对应一个邀请码，必须做到唯一性。邀请码的需要手动输入所以长度不能太长，同时不能让用户猜到邀请码的生成逻辑，所以邀请的生成逻辑也必须要随机。</summary>
    
    
    
    
    <category term="代码设计" scheme="https://www.leeee.xyz/tags/%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>MYSQL索引为什么这么快?了解索引的神奇之处</title>
    <link href="https://www.leeee.xyz/posts/3b645433/"/>
    <id>https://www.leeee.xyz/posts/3b645433/</id>
    <published>2022-05-08T01:24:57.000Z</published>
    <updated>2025-04-15T07:23:40.194Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>公司最近组织开展一系列的技术分享会，我借着这次机会把自己以前学的一些知识点重新归纳一下记录起来。首先是对自己技术的积累有好处，其次也是想让自己学习的知识能够更深入的理解，有不足或者错误的地方欢迎指出，共同进步。<br>探究一下MYSQL索引为什么这么快？索引究竟是什么？</p></blockquote><h2 id="1-什么是索引？"><a href="#1-什么是索引？" class="headerlink" title="1.什么是索引？"></a>1.什么是索引？</h2><ul><li>MYSQL官方文档介绍索引是一种方便快速查询数据的<strong>数据结构</strong>。用我们生活中的例子来讲，索引就好比书的目录，如果没有目录，每次你想要查找某些内容，你必须从头开始查找，这样的效率极其低下。</li><li>索引一般比较大，所以大部分情况下索引是存在磁盘的索引文件上，也有可能是存在数据文件上。</li><li>索引的种类有很多：主键索引（这是最常见的一种索引，主键不能为空且必须唯一）、唯一索引（相对于主键索引，它的值可以为空）、全文索引（在char、varchar、text类型可以使用）、普通索引、前缀索引。按照列数来区分：单一索引、组合索引（多字段组成）</li></ul><h2 id="2-MYSQL索引的数据结构"><a href="#2-MYSQL索引的数据结构" class="headerlink" title="2.MYSQL索引的数据结构"></a>2.MYSQL索引的数据结构</h2><p>在讲解MYSQL索引的数据结构之前，我们先看看了解一下其他的数据结构，看看他们的优缺点进行对比。</p><h3 id="2-1-二叉树"><a href="#2-1-二叉树" class="headerlink" title="2.1 二叉树"></a>2.1 二叉树</h3><p>二叉树简单来说就是左节点大于右节点，在理想的情况下，他的查找速度就接近与二分法的性能O(log2n)。因为在内存排序的时间是非常快的，可以忽略不计，所以总的消耗时间就取决于IO的操作次数。二叉树查找速度取决树高,每次查询接口都是一次IO操作，也是性能的瓶颈所在。<br><img src="/posts/3b645433/1.png"><br>但是也会有这种一种情况,同样也是二叉树，但是他的树非常高，导致查询一次需要多次IO操作，效率及其低下<br><img src="/posts/3b645433/2.png"></p><h3 id="2-2-平衡二叉树"><a href="#2-2-平衡二叉树" class="headerlink" title="2.2 平衡二叉树"></a>2.2 平衡二叉树</h3><p>平衡二叉树可以解决二叉树不稳定导致查询效率低下的缺点。平衡二叉树的特点：树的左右节点层级最高相差一层。在插入或者删除的情况下，通过左旋转或右旋转使得整个二叉树平衡，不会出现层级相差很多的情况。平衡二叉树的性能接近二分法查找O(log2n)。<br><img src="/posts/3b645433/3.png"><br>平衡二叉树查找id为8的记录，只需要IO操作2次即可。但是仔细想一下，如果数据量很多呢？假设数据表有100W的数据，根据O(log2n)计算，大约需要20次IO操作。磁盘寻道大概需要10ms，总的查询时间为20 * 10 &#x3D; 0.2，效率也比较低下。<br>还有就是平衡二叉树不支持范围查询，范围查询每次都需要从根节点遍历，效率及其低下。</p><h3 id="2-3-B-树-改造二叉树成多叉树"><a href="#2-3-B-树-改造二叉树成多叉树" class="headerlink" title="2.3 B-树(改造二叉树成多叉树)"></a>2.3 B-树(改造二叉树成多叉树)</h3><p>之前的几种树形结构适合与小数据量的内存查找，也叫做内查找。在1970年，R.Bayer和E.Mccreight提出了一种适合于外查找的平衡多叉树B-树。MYSQL数据文件是存在磁盘的，每次都是按照一页大小（一般而16K）读取内存。像二叉树、平衡二叉树，每次读取节点都要进行一次IO操作，所以树越高IO操作次数越多。想要提高查询效率，首先要解决的就是降低树高的问题。<br>设想一下，每一次IO操作读取一个节点，读取16K大小的内存数据，但是每次节点的数据实际上远远小于16K。假设节点数据大小为16B，为了让一次IO操作能够读取更多节点，我们可以在每个节点尽可能地存储索引数据。我们在每个节点存储1000个索引数据（1000*16B &#x3D; 16K），将二叉树改造成多叉树，从树高变成树“胖”，解决了树高的问题，从而降低IO操作次数，提高查询效率。<br><img src="/posts/3b645433/4.png"><br>B-树的特点：1.每个节点存储多个元素 2.节点的元素包含键值以及数据 3.所有叶子节点存放同一层，具有相同深度，叶子节点之间没有指针连接。这种数据结构解决了树高IO次数多的问题，但是在每个节点存储数据，假设数据一旦很大，每个节点储存的索引数也随之减少，最后还是会导致树很高，查询效率低。其次，B-树不能范围查询。设想一下如果我们要查询15-25范围内的数据，查到15之后就又要重新回到根节点继续查找，这样循环遍历的效率有待提高。</p><h3 id="2-4-B-树（改造B-树）"><a href="#2-4-B-树（改造B-树）" class="headerlink" title="2.4 B+树（改造B-树）"></a>2.4 B+树（改造B-树）</h3><p>结合了B-树的缺点进行改造，就诞生了B+树。B+树跟B-树的差异并不是很大，判断的依据很简单：节点是否存放数据。B+树存放数据的节点只有叶子节点，而且叶子结点双向指针连接，形成了双向有序链表。<br><img src="/posts/3b645433/5.png"><br>这样一来，除了叶子节点其他存放的都是索引键值，可以很大程度增加节点存放索引树，从理论上树是要比B-树“矮”的。同时B+树支持范围查询，因为底层叶子节点是双向有序链表，而且主键具有唯一性（对于辅助索引后面会讲到），假设范围为15到19，我们只需要查到15记录之后继续往后查询，直到大于19即可，无需从根节点再次遍历，效率较高。</p><h2 id="3-MYSQL索引B-树实践"><a href="#3-MYSQL索引B-树实践" class="headerlink" title="3.MYSQL索引B+树实践"></a>3.MYSQL索引B+树实践</h2><h3 id="MYISAM引擎-主键索引"><a href="#MYISAM引擎-主键索引" class="headerlink" title="MYISAM引擎 (主键索引)"></a>MYISAM引擎 (主键索引)</h3><p>MYISAM引擎是非聚簇索引，也就是说B+树的叶子节点的键值存放索引列的值，数据存在数据在磁盘的地址。MYISAM的索引文件跟数据文件是分开存储的。<br><code>CREATE TABLE</code>student<code>(</code>id<code>int(11) NOT NULL AUTO_INCREMENT,</code>name<code>varchar(20) DEFAULT NULL,</code>age<code>int(11) DEFAULT NULL, PRIMARY KEY (</code>id<code>) USING BTREE, KEY</code>idx_age<code>(</code>age<code>) USING BTREE ) ENGINE = MyISAM AUTO_INCREMENT = 1 DEFAULT CHARSET = utf8;</code><br>创建了一个表student，id为主键索引,age为普通索引。假设表中有以下数据，现在执行以下语句<br><code>SELECT * FROM stduent WHERE id = 16</code><br><img src="/posts/3b645433/6.png"><br>具体链路：（实际上逻辑上相邻实际磁盘并不一定相邻，这里只是方便展示）<br>（1）先从磁盘1加载数据到内存，因为18&gt;16走左路（一次IO操作） （2）读取磁盘2加载数据到内存，又因为16&gt;14向下继续读取（一次IO操作） （3）检索叶子节点，判断到等于16则停止（一次IO操作）<br><img src="/posts/3b645433/7.png"></p><h3 id="MYISAM引擎-辅助索引"><a href="#MYISAM引擎-辅助索引" class="headerlink" title="MYISAM引擎 (辅助索引)"></a>MYISAM引擎 (辅助索引)</h3><p>在MYISAM引擎中，主键索引跟辅助索引的差别并不很大，叶子节点存放的都是磁盘地址，只是辅助索引并并不是唯一值，所以在等值查询检索叶子节点的时候，也要按照范围一样，进行检索数据。</p><h3 id="Innodb引擎-（聚簇索引、主键索引）"><a href="#Innodb引擎-（聚簇索引、主键索引）" class="headerlink" title="Innodb引擎 （聚簇索引、主键索引）"></a>Innodb引擎 （聚簇索引、主键索引）</h3><p>Innodb引擎使用的是聚簇索引。每一个数据表都有一个聚簇索引，采用B+树的数据结构，叶子节点键值对应存放的是整行数据记录。在Innodb中，非聚簇索引就是辅助索引,叶子节点存储的数据是主键值。如果一个表没有主键，innodb引擎会自动构建一个隐藏的rowid在构成聚簇索引。依旧是按照我们刚刚讲解MYISAM引擎的数据表例子：<br><code>SELECT * FROM stduent WHERE age = 37</code><br><img src="/posts/3b645433/8.png"></p><p>具体链路：（实际上逻辑上相邻实际磁盘并不一定相邻，这里只是方便展示）<br><img src="/posts/3b645433/9.png"></p><p>（1）先从磁盘1加载数据到内存，因为18&lt;37走左路（一次IO操作） （2）读取磁盘2加载数据到内存，又因为37&gt;24向下继续读取（一次IO操作） （3）检索叶子节点，判断到等于37则停止（一次IO操作） （4）这时候查到的数据就是age字段为37的记录主键值。按照聚簇索引的方式再查找数据就得到了数据结构集（这个过程叫做回表）相同索引字段情况下，按主键字段排序。因为要多加上三次回表操作，效率回相对低一点点。这里有个概念叫做<strong>覆盖索引</strong>，如果查询所需要的字段刚好就是索引字段就不需要回表查询，从而提高了查询效率。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>索引的原理远远不止于这么一点点，组合索引以及一些其他的原理我暂时理解还不是到位，等到后面学习更加理解之后再写一篇文章进行记录总结吧。“学而不思则惘，思而不学则殆”，以前没办法理解这句话的涵义，直到后来才知道总结、思考才是学习最有效率的方式。多总结、多思考，也是作为一名程序员进步的最快方式。</p>]]></content>
    
    
    <summary type="html">公司最近组织开展一系列的技术分享会，我借着这次机会把自己以前学的一些知识点重新归纳一下记录起来。首先是对自己技术的积累有好处，其次也是想让自己学习的知识能够更深入的理解，有不足或者错误的地方欢迎指出，共同进步。探究一下MYSQL索引为什么这么快？索引究竟是什么？</summary>
    
    
    
    <category term="数据库" scheme="https://www.leeee.xyz/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="mysql" scheme="https://www.leeee.xyz/tags/mysql/"/>
    
    <category term="数据库索引" scheme="https://www.leeee.xyz/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/"/>
    
    <category term="Innodb" scheme="https://www.leeee.xyz/tags/Innodb/"/>
    
  </entry>
  
  <entry>
    <title>PHP策略模式在业务的实践总结</title>
    <link href="https://www.leeee.xyz/posts/fa2b266c/"/>
    <id>https://www.leeee.xyz/posts/fa2b266c/</id>
    <published>2021-12-09T01:14:18.000Z</published>
    <updated>2025-04-15T07:23:40.199Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>【大话设计模式】– 策略者模式(<strong>Strategy</strong>):它定义了算法家族,分别封装起来，让他们之间可以互相替换，此模式让算法的变法，不会影响到使用算法的客户。</p></blockquote><p><strong>策略模式</strong>的核心就是屏蔽内部策略算法，内部的算法是可以随时替换，对外部是没有感知的。若新增或修改内部的算法，只需要修改或者扩展相应的策略类，客户端的代码无需改动,符合设计模式中一个重要的原则：开闭原则。</p><h2 id="一-业务需求背景"><a href="#一-业务需求背景" class="headerlink" title="一. 业务需求背景"></a>一. 业务需求背景</h2><p>1.需求目的：<br>用户可以进行对某种配置进行预约，到达配置的预约时间点，根据Redis队列的预约号执行预约，不同类型的配置预约操作逻辑完全不同。<br>2.流程图：<img src="/posts/fa2b266c/1.png"></p><h2 id="二-使用策略模式的缘由"><a href="#二-使用策略模式的缘由" class="headerlink" title="二. 使用策略模式的缘由"></a>二. 使用策略模式的缘由</h2><p>此业务由于是要支持不同配置的预约，以及后期可能会有很多种类型的配置，而且不同类型的配置又完成不同，如果直接编码，后期的扩展性以及维护性会比较麻烦。<br>1.正常代码实现：</p><pre><code class="php">&lt;?php    public function makeReservation($mainkey)&#123;        $type = getReservationTypeByMainkey($mainkey);        switch($type):&#123;            case &#39;A&#39;:            $this-&gt;reservationAConfig($mainkey);            break;            case &#39;B&#39;:            $this-&gt;reservationBConfig($mainkey);            break;            .....        &#125;    &#125;        private function reservationAConfig($mainkey)&#123;        //这里进行A配置的预约逻辑操作    &#125;        private function reservationBConfig($mainkey)&#123;        //这里进行B配置的预约逻辑操作    &#125;        private function getReservationTypeByMainkey($mainkey)&#123;        //根据预约号获取预约配置的类型    &#125;</code></pre><p>这样子的实现也是可以满足业务需求，代码的可读性也还好。但是会有一个问题，这种预约的配置种类会很多，会导致switch的语句会越来越多，也可能会修改一些预约配置逻辑。这样子的话就需要修改原来的代码，对于代码质量来说，这并不是一种好的现象。</p><p>2.策略模式实现<br><img src="/posts/fa2b266c/2.png"></p><pre><code class="php">&lt;?phpinterface ReservationStrategy&#123;    //执行预约配置逻辑操作    public function makeReservation();&#125;//策略处理类class ReservationHandler&#123;    private $strategy = null;    public function __construct(ReservationStrategy $strategy)&#123;        $this-&gt;$strategy = $strategy;    &#125;        //封装了策略执行的逻辑，所有执行的预约配置统一调用这个方法    public function makeReservation()&#123;        $this-&gt;$strategy-&gt;makeReservation();    &#125;&#125;//A配置的具体策略类class AReservationStrategy implements ReservationStrategy&#123;    public function makeReservation()&#123;        //这里执行A配置的逻辑操作    ;&#125;class ReservationFacaory&#123;    public static function getReservationInstance($mainkey)&#123;        //这里可以根据预约号做具体逻辑生成策略对象    &#125;&#125;//预约控制器代码class ReservationController&#123;    public function makeReservation($mainkey)&#123;        //根据工厂对象创建预约策略实例        $reservation = ReservationFacaory::getReservationInstance($mainkey);        //传入实例给策略处理类        $handler = new ReservationHandler($reservation);        //执行预约策略        $handler-&gt;makeReservation();    &#125;&#125;</code></pre><p>以上代码使用了<strong>工厂模式</strong>以及<strong>策略模式</strong>的结合，其中<strong>ReservationHandler</strong>类作为处理上下文的类，通过依赖注入相应的策略类，直接调用<strong>makeReservation</strong>方法。在客户端代码只需要调用此方法即可，即使后期预约逻辑也无需改动客户端的代码。在此业务需求，因为需求并不是很大，所以工厂类只是简单实现。如果想要更完善，工厂类根据反射机制以及约定好的类名动态生成实例，这样后期如果扩展类型，只需要实现相应的接口即可，无需改动其他代码，很方便扩展。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实践才能出真知。以前看大话<strong>设计模式</strong>这本书，总觉得自己看了好多遍但是还是云里雾里的，不知道为什么需要这种代码结构。但是通过一个小需求设计这么一个结构，我很快就能get到这种结构带来的好处。虽然在这个业务上，这种结构的优势并没有特别的明显，甚至可能有点增加代码量，但是我相信在后期扩展以及维护方便是有很大的好处的。记录这篇文章，主要是想要记录自己的思考方式以及学习体会，如果有一些不太对的地方欢迎大家指正，一起进步！！</p>]]></content>
    
    
    <summary type="html">【大话设计模式】-- 策略者模式(**Strategy**):它定义了算法家族,分别封装起来，让他们之间可以互相替换，此模式让算法的变法，不会影响到使用算法的客户。</summary>
    
    
    
    <category term="设计模式" scheme="https://www.leeee.xyz/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="代码设计" scheme="https://www.leeee.xyz/tags/%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="PHP" scheme="https://www.leeee.xyz/tags/PHP/"/>
    
  </entry>
  
</feed>
